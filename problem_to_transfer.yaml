--- # this is a data structure
id: partition-refinement
name: Partition refinement
description: Maintain a partition $\mathcal{X}$ of $[m]$, such that taking a input set $S$, it creates a new partition $\mathcal{X}_S = \set{ X\cap S, X\setminus S |X\in \mathcal{X} }$.
parameters:
  n: size of $S$
note: We want $O(n)$ time per operation. This is the partition refinement data structure.
---

---
description: The [proportional apportionment](https://chaoxuprime.com/posts/2016-08-02-proportional-apportionment.html)
---
description: A tree on $n$ vertices with weights on the vertices. Finding height, max, min of the tree. 
---
name: Subset sum
description: Given $u$ and $S\subset [u]$ of size $n$, decide if there is a subset of $S$ that sums to $u$.
tag: [subset sum]
parameters:
  n: the size of $S$.
  u:
  \sigma: the sum of all elements in $S$.
  r: $\min(S)$
  M: $\max(S)$
exercises: 
  - Show the problem can be solved in $O(nu)$ time through dynamic programming.
comments:
  - $O(\sqrt{n\log n}u\log u)$
  - $O(nu)$
  - $O(\sigma \log \sigma \log n)$. 
  - $O(u^{5/4}\log^2 u)$
  - $O(M^{5/3})$
  - $O(u^2/r)$
---
name: Subset sum with cardinality table up to $u$
description: Given $u$ and $S\subset [u]$ of size $n$, compute a set $T$ such that $(i,j)$ in $T$ if and only if there exists a subset of $S$ of size $j$ that sums to $i$, and $i\leq u$. 
tag: [subset sum]
comments: 
  - $O(nu\log u\log n)$
  - $O(n^2u)$
---
name: Subset sum with cardinality table
description: Given $S$ a sequence of $n$ positive integers that sums to $\sigma$, compute a set $T$ such that $(i,j)$ in $T$ if and only if there exists a subset of $S$ of size $j$ that sums to $i$. 
tag: [subset sum]
comments: 
  - $O(n\sigma \log n\sigma)$
  - $O(n^2\sigma)$
---
name: Subset sum with cardinality and count
description: Given $u$ and $S\subset [u]$ of size $n$, compute the function $f$ such that $f(i,j)$ is the number of subsets of $S$ of size $j$ that sums to $i$.
tag: [subset sum]

---
name: Sorting
description: Sort a sequence in a stable way.
exercises:
  - Every comparison sorting algorithm can be made stable. Instead of sort $s_1,\ldots,s_n$, sorting the sequence $(s_1,1),\ldots,(s_n,n)$

---
id: integer-sorting
name: Integer sorting
description: Given a list of positive integers, return the sorted list
parameters:
  n: the length of the list
  m: an upper bound of the elements in the list
exercises:
  - Show a running time of $O(n+m)$ can be achieved
  - Show a running time of $O(n\log m)$ can be achieved
  - Show a running time of $O(n \log_n m)$ can be achieved
note: Basically, counting sort, radix sort with constant size base and radix sort with size $n$ base. In particular, this shows sorting elements in $[n^c]$ can be done in $O(n)$ time.
algorithms:
  - description: counting sort
    complexity: $O(n+m)$
    opt: false
  - description: radix sort with base $n$
    complexity: $O(n\log_n m)$

---
description: Sort $X$ if the time of comparing two element equals to the sum of the weight of the element.
parameters:
  n: the number of elements in $X$
  w: the weight function $w:X\to \N$.
exercises:
  - use the fact that there is a sorting network of $O(\log n)$ depth and $O(n\log n)$ size show sorting it can be done in $O(\sum_{x\in X} w(x) \log n)$ time. 
  - Show sorting strings lexicographcially can be done in $O(m\log n)$ time, where $m$ is the total length of the strings.

---
id: exponential-search
name: Exponential search
description: Let $p$ be a monotonic predicate over positive integers, find the smallest value that is is true.
parameters:
  n: the smallest value such that $p(n)$ is true.
exercises: 
  - Show it can be done in $O(\log n)$ time.

---
name: Binary search
description: Let $S$ be a sorted array. Find the smallest index $i$ such that $S[i]\geq x$.
parameters:
  n: the number of elements in $S$
exercises:
  - Show it reduces to the previous exponential search.

---
name: multiple exponential search
description: Let $S$ be a sorted array. Let $T$ be a set, for each element $x\in T$ find the smallest $i$ such that $S[i]\geq x$.
parameters:
  n: the number of elements in $S$
  m: the size of $T$
exercises:
  - Show it takes $O(m\log \frac{n}{m})$ time. 

---
name: Selection in sorted arrays
description: Given a collection of sorted arrays, find the rank $k$ element in the union of the arrays.
parameters:
  n: the number of sorted arrays
  m_i: the number of elements in the $i$th sorted array
  k:
exercises:
  - Find $O(\log k)$ time algorithm when there are $2$ sorted arrays.
  - Find a $O(n\log k)$ time algorithm.
note: Let $p=\min(k,n)$, and $m_i$ be the length of the $i$th array.
  - $O(n+p\log k/p)$ [@FredericksonJ82]
  - $O(k+\sum_{i=1}^n m_i)$ [@FredericksonJ80].

--- 
name: Bitonic sequence minimum
description: Given a bitonic sequence, find the minimum element. 
parameters:
  n: the length of the array.
  k: the maximum number an element can appear.
exercises:
  - Find the minimum in $O(k+\log n)$ time.
  - Find if an element exists in $O(k+\log n)$ time. 
---
name: Rotation of a sorted array
description: Let $n$ be a rotation of a sorted array consist of distinct elements, find if an element $x$ is in the array.
note: rotation of a sorted array is bitonic.

---
id: soft-heap
name: Soft heap
description: todo, just read [soft heap](https://en.wikipedia.org/wiki/Soft_heap) here
--- 
id: median
name: Median of an array
tag: [selection]
description: Given an array find the median.
parameters:
  n: the length of the array.
algorithms:
  - description: median of median recursion
    complexity: $O(n)$ time
  - description: use a soft-heap find approximate range of the element, and recur in the range.
    problem: soft-heap
    complexity: $O(n)$ time
exercises:
  - There are $k$ points on a circle, find a line such that there are same number [bisect a circle with same number of points](https://chaoxuprime.com/posts/2014-03-27-bisect-circle-even-point-set.html)
  - There are red points and blue points on the plane, find a line so the number of red points and blue points on each side is the same. 

--- 
id: selection
name: Unordered selection 
tag: [selection]
description: Given an array of elements of length $n$, find rank $k$ element.
parameters:
  n: the length of the array.
note: Linear time through soft-heap or median of median
algorithms:
  - description: find median, recur on the correct side
    complexity: $O(n)$ time
children:
  median: select the rank $\floor{n/2}$ element

--- 
id: weighted-selection
name: Unordered weighted selection
tag: [selection]
description: Given an array where each element has an associated weight. Find weighted rank $k$ element. 
parameters:
  n: the length of the array.
note: The weighted median problem
children:
  selection: the weight of each element is $1$. 
algorithms:
  - description: find the median and partition, check if weighted rank in which side, recur in the correct side
    problem: median
    complexity: $O(n)$ time

--- 
id: unordered-search
name: Unordered search
tag: [selection]
description: Given an array of elements, and an oracle decides if $x\leq y$ or $x>y$, where $y$ is an unknown value. Find the largest value in the array that is no larger than $y$.
parameters:
  n: the length of the array
algorithms:
  - description: find median, partition, decide which side $y$ lies and recur. 
    problem: median
    complexity: $O(n)$ time and $O(\log n)$ oracle calls

---
name: Selection in sorted matrix
tag: [selection]
description: Given a sorted matrix $M$, find the rank $k$ element.
parameters:
  n: number of rows of $M$
  m: number of columns of $M$, assume $n\leq m$.
  k:
exercises:
  - Show we can assume $k\geq m$. 
  - Show this can be done in $O(k\log k)$ time.
  - Let $r(a,A)$ be the number of elements in matrix $A$ smaller or equal to $a$. Let $A_o$ be the matrix we obtain from $A$ by removing all even columns. Show if $A$ is a sorted $n\times m$ matrix, then $2(r(a,A_o)-n)\leq r(a,A) \leq 2r(a,A_o)$.
  - Show that there is a $O(m)$ time algorithm to find the $k$th smallest element. (Recursively solve the problem by solving the problem on $A_o$. Use $A_o$ to bound the search space in $A$. )
  - Show there is an algorithm with runnning time $O(n \log m/n)$ time. 
  - Can you modify the algorithm to output a description of all elements smaller than the $k$th smallest element? (i.e. for each $i$, find $j_i$, such that all elements before $j_i$ satisfies the property.) What's the running time? Is $O(n)$ time possible?
---
name: Search in infinite sorted matrix
tag: [selection]
description: Given a sorted infinite matrix $M$, and an oracle that decide if an element is at least $x$ or greater than $x$. Find the smallest value that is at most $x$ in the matrix.
parameters: 
  n: the largest value where $M_{n,1}\leq x$.
  m: the largest value where $M_{1,m}\leq x$.
  t: the largest value where $M_{t,t}\leq x$.
  k: $|\set{(i,j)| M_{i,j}\leq x}|$.
exercises:
  - Show there is an algorithm with running time and matrix access both $O(n\log m/n)$ and $O(\log nm)$ oracle calls.
  - Let $t$ be the smallest integer such that $M_{t,t}>x$. Show there is a $O(\log k)$ oracle call and $O(t \log k/t)$ time algorithm. 
  - Show there is an $O(\sqrt{k})$ time algorithm with $O(\log k)$ oracle calls.
algorithms:
  - description: Find $t,n$ and $m$ using exponential search on diagonal, first row and first column. Apply search on a $t\times n$ and $t\times m$ matrix. This uses algorithm [@Jacob08].
    problem: ["median", "exponential-search"]
    complexity: $O(t\log k/t)$ time, $O(\log k)$ oracle calls. 
note: what is the generalization to multidimentional arrays?
children:
  exponential-search: One has extra knowledge that $n=1$.
--- 
name: Maximum XOR Subarray
description: Given an array of non-negative integers. Find a subarray such that its XOR value is maximized.
note: This is Lintcode 722, Maximum Subarray VI

---
name: Single source shortest path tree in directed graph
description: Given a directed graph and a vertex $s$, find the shortest path tree rooted at $s$.
note: If cost are integers bounded by $C$, then we have a parameter $C$.
  - $O(m+n\log n)$ 
  - $O(m)$ if graph is DAG
  - $O(m\log \log n)$ [@Thorup00] for integer cost
  - $O(m+n \min(\log^{1/3+\e}n, \log^{1/4+\e} C))$ [@Raman97] for integer cost
  - $O(nm)$ Allowing negative weights
---
name: Single source shortest $2$-disjoint paths to all sinks
description: Given a directed graph and a vertex $s$, for each $v$, find the shortest $2$-disjoint path from $s$ to $v$.
note: If instead of $2$, it is $3$. I have no idea if a similar running time is possible. 
  - $O(m+n\log n)$ Suurballe's algorithm.

---
name: Single source shortest path tree in undirected graph
description: Given a undirected graph and a vertex $s$, find the shortest path tree rooted at $s$.
  - same as directed graph
  - $O(m)$ if positive integer weight [@Thorup99]
---


name: All-pair shortest path
description: Given a directed graph with positive and negative edges, find the distance function or indicate there is a negative cycle.
  - $O(nm+n^2\log n)$
---
name: DAG longest path
description: Given a DAG, find the longest path in the DAG

---
name: Lights out game
description: Solve $Ax=b$ where $b\in \F_2$ and $A$ is the incident matrix of a undirected graph.
exercises:
  - Show if the graph is a $n\times m$ grid graph, then $O(nm^2)$ running time is possible. 

---
description: Single source replacement path

---
description: Continous Weak Frechet distance in 1D [See](https://arxiv.org/abs/1807.08699).

--- 
name: Find induced $P_3$.
description: Find a induced $P_3$ in a undirected graph.
exercises:
  - Show a linear time algorithm.

--- 
name: Find a $C_4$
description: Find a $C_4$ in a undirected graph.
exercises:
  - Show $O(n^2)$ time algorithm.
  - Show a $O(m\sqrt{n})$ time algorithm.
  - Show a $O(m^{4/3})$ time algorithm. (Use the fact about degenercy)
note:
  For a graph with at least $100kn^{1+1/k}$ edges, then there is a $C_{2\ell}$ for every $\ell\in [k,n^{1/k}]$.

---
name: Find a triangle
description: Find a triangle in a undirected graph.
exercises:
  - Show a $O(n^3)$ time algorithm.
  - Show a $O(n^\omega)$ time algorithm.
  - Show a $O(m^{3/2})$ time algorithm.
  - Speed it up further. 

---
name: Find a cycle of minimum weight.
description: Find a cycle of minimum weight in a directed graph.
exercises:
  - Show a solution using dijkstra $O(n)$ times.
note: Orlin had a $O(nm)$ time algorithm
---
name: Find a cycle of minimum weight that contains specified $k$ vertices
description: Given undirected graph and a subset of $k$ vertices, find a shortest cycle that contains them all.
note: the problem is NP-hard when $k\geq 2$ for directed graphs. [A good survey](https://arxiv.org/abs/1705.00055).
  - $k=1,2$, $O(m+n\log n)$, reduces to single source shortest $2$-disjoint paths to all sinks
  - polynomial time for feasbility test for constant $k$, as it reduces to disjoint path problem. 
  - open for $k\geq 3$. randomized polynomial time algorithm exists for each constant $k$.

---
name: Minimum average weight cycle
description: Find a cycle with minimum average weight. That is, the total weight divided by the number of edges is minimum.

---
name: Steiner tree on constant number of vertices
description: Given $k$, a constant number of vertices, find a minimum Steiner tree.
opt : polynomial time.

---
description: for each edge, find a min-weight matching that contains the edge.
tag: matching


---
description: For a bipartite graph $G=(A,B,E)$, find $M$ such that $\deg_M(v)=1$ for all $v\in A$, and the degree sequence of vertices in $B$ is lexicographcially maximum.
tag: matching
note: this is the optimal semi-matching problem.

--- 
description: Let $S_1,\ldots,S_n$ be a sequence of sets, where the sum of the sizes is $m$. Partition $[n]$ such that $S_i=S_j$ iff $i$ and $j$ are in the same partition classes.
exercises:
  - Show this can be solved in $O(m)$ time.

---
description: Let $S_1,\ldots,S_n$ be a sequence of sets, decide if there are two sets such that $S_i\cap S_j\geq k$.
exercises:
  - Show if $k=1,0$, then $O(m)$ time is sufficient
  - Show if $k=2$, then $O(m^{4/3})$ time is sufficient (convert to finding $C_4$)
  - Show if $k=3$, there is a $O(m^{2-\delta})$ time algorithm where $\delta$ is a constant strictly larger than $0$. (See [this](https://chaoxuprime.com/posts/2019-01-21-high-degree-low-degree-technique.html) for a solution.)

---
description: Given a collection of sets, find all maximal sets and all minimal sets.
tag: set system

---
description: Find a weakly connected dominating set such that the sum of degrees is $O(n\sqrt{n\log n})$.
note: This result is used in matroid $4$-connectivity algorithms. See [this](https://chaoxuprime.com/posts/2019-01-21-high-degree-low-degree-technique.html).

--- 
name: Lexicographically minimal string rotation
description: Given a string, find a rotation that is lexicographically minimal.
tag: string

---
name: String matching
description: Given strings $s$ and $t$, decide if $t$ is an substring of $s$.
tag: string, pattern matching

---
name: Isomorphic subtrees
description: For each node, find all nodes with isomorphic subtrees.
tag: pattern matching
exercises: 
  - Show how to find the most common subtree. 
note: See [this](https://chaoxuprime.com/posts/2014-06-05-pattern-in-labeled-ordered-rooted-trees.html). Note that the problem have different variations. The tree can be rooted/unrooted, ordered/unordered, labeled/unlabeled. All variations can be solved by [one algorithm](https://link.springer.com/chapter/10.1007%2F978-3-642-45278-9_23) with $O(n)$ running time. 

---
name: Multiple string matching
description: Given strings $s$ and $t_1,\ldots,t_k$, find the matching positions for each $t_i$.
tag: string, pattern matching
note: expect running time $O(n+m)$, where $m$ is the total length of $t_1,\ldots,t_k$ and $n$ is the length of $s$.

---
description: Given a set of $n$ strings, each of length $m$, decide if any two strings where the sum of the length of matched prefix and matched suffix is at least $k$.
tag: string
note: See a solution [here](https://chaoxuprime.com/posts/2018-12-23-strings-with-hamming-distance-exactly-1.html). It work for $k=m-1$, but the same algorithm work for larger $k$, too.

---
description: Given string $s$, find a primitive string $p$ such that $p^k=s$.

---
description: Find the period of a string. 
exercises:
  - Show a string is periodic if and only if it has a proper border of length at least $\ceil{n/2}$.
  - If the string is periodic, then the period is the length of the maximum proper border.
---
description: Find the longest periodic suffix. 
exercises:
  - Use suffix tree to solve this in $O(n)$ time.
tag: [string]
---
description: Decide if a set forms a uniquely decodable code. 
---
description: Find the largest subset that forms a uniquely decodable code. 
note: I think the problem is open.
---
description: Find the first substring of length $t$ that appears at least twice.
---
description: Given $u$ and a $u$-normal eventually periodic string $s$, find the the minimum split $(a,b)$ of $s$. 
exercises:
  - Let $n$ be length of $a$. Find an algorithm with running time $O((n+u)u)$. 
  - Given an index $i$ such that $i<n\leq i+2u$, find $n$. Show this can be done in $O(u)$ time.
  - Find the pairs $(a,b)$ in $O(n+u)$ time.
  - Show one can directly use a online suffix tree construction algorithm to obtain the same running time. 
note: An infinite string is given as a function, $s:\N\to \Sigma$. It take an index and output the character at the index. 
  We say $(a,b)$ is a *split* of $s$ if $ab=s$ and $b$ is a infinite periodic string. A split $(a,b)$ is minimum, if period of $b$ is minimum and under the previous constraint, length of $a$ is minimum. 
  An eventually periodic string $s$ is *$u$-normal*, if for any two indices $i<j$, where $j-i\leq u$ and $s[i..i+u] = s[j..j+u]$, there exists a split $(a,b)$ of $s$ where $|a|\leq i$, and the period of $b$ is at most $u$.
---
description: Given $u$ and $n$ and a eventually periodic sequence with initial sequence length at most $n$ and period at most $n$, find the initial sequence and the periodic sequence. 
---
description: parametric string matching. [Look into it.](https://arxiv.org/abs/1603.07457)
---
description: data structure for loaded die. 
note: see [this](http://stackoverflow.com/questions/5027757/data-structure-for-loaded-dice)
---
description: You have a data stream of a permutation of $\set{1,\ldots,n}$. However you know $k$ of the elements will be missing because the communication channel has fault. How can you detect which numbers are missing? 
note: see [this](http://stackoverflow.com/questions/3492302/easy-interview-question-got-harder-given-numbers-1-100-find-the-missing-numbe)
---
description: 
  Let $x=p/q$ be an rational number, where $p$ and $q$ are integers. There is a function $f_x$, such that $f_x(y)$ tells you if $x < y$, $x > y$ or $x=y$. Find $x$? 
note: see [this](http://stackoverflow.com/questions/5440688/the-guess-the-number-game-for-arbitrary-rational-numbers). Maybe it can be reduced to search in a sorted matrix?
--- 
description: decide for the coins if the greedy algorithm work for the coin change problem for a input set of coins.
note: See http://graal.ens-lyon.fr/~abenoit/algo09/coins2.pdf
---
description: test if a point is inside a polygon. also consider convex version
---
description: sliding window min, median, $k$th largest, max sum, etc.
exercises:
  - Find the shortest subarray such that the sum is at least $k$.
---
description: cycle finding
note: probably can use it for eventually periodic sequence
---
description: A infinite sorted matrix, search for largest element no larger than $y$, whre we have an oracle that decides if a input is lesser or equal to, or greater than $y$
note: We want running time and oracle calls to depend on the number of elements smaller than $y$.
---
description: find a celebrity in a graph (vertex with only incoming edge and no outgoing edge)
note: A subset of vertices is a celebrity clique, if the subset induces a clique, and only have incoming edges. can this be found quickly too?
---
description: Given $k$-edge-disjoint path between $u$ and $v$ and $v$ and $w$, total of $m$ edges. Find $k$-edge-disjoint path between $u$ and $w$.
note: can be done in linear $O(m)$ time.
---
description: a data structure that takes $u,v,w$ and output if $v$ is in the $uw$-path. 
---
description: least common ancestor, level ancestor of a tree. 
---
description: range minimum query on path, tree
---
description: range minimum query on multidimentional array
---
description: Lexicographic bottleneck shortest path in undirected graph
note: y [Lexicographic bottleneck shortest path in undirected graph](/posts/2014-05-10-lexicographical-bottleneck-path.html)
---
description: Given a weighted forest. Connect the forests with edges of weight $L$ to get a spanning tree such that the diameter of the spanning tree is minimized. (Dreaming, IOI 2013)
note: so it is the same as adding $k$ edges to minimize diameter.
---
description: Given a tree with weight on the edges, create a data structure such given $u,v$, find the weight of the $uv$-path.
note: due to it is a monoid, we can't do substraction. However, $O(\alpha(n))$ query time and $O(n)$ preprocessing time is possible I think. search for "OPTIMAL PREPROCESSING FOR ANSWERING ON-LINE PRODUCT QUERIES", also check Chazelle's paper on free trees.
---
description: given a graph with $m$ edges, such that we can only check if two pointer points to the same vertex using an oracle. Construct a data structure that check if an edge is in the graph.
note: A $O(m/n)$ query time data structure exists. In fact, $O(\alpha(G))$ which is the arboricity of the graph.
---
description: Find the bottleneck shortest $st$-path
note: $O(m)$ time possible if there an ordered list of edges by weight.
---
description: stable matching in a graph
note: linear time algorithm always exists, crazy
---
description: You are given $k$ stacks $S_1,\ldots,S_k$. You know everything about the stacks(you can inspect all elements in the stacks without poping them). Assume the stacks have a total of $n$ elements. You want to pop all the elements from the stacks in such a way such that $S_1.peek()\leq S_2.peek()\leq \ldots \leq S_k.peek()$ is always true. Note that we define $S_i.peek()=\infty$ if $S_i$ is empty. Come up with an algorithm to decide if this is possible.
note: this is weird, why did I think of this problem?
---
description: Given $a_1\leq \ldots \leq a_k$, partition a set of $n$ numbers into $k$ sets, such that each set contains numbers of the rank greater or equal to $a_i$ and smaller than $a_{i+1}$.
---
description: Find the maximum $k$ cover. namely disjoint $k$ intervals that sums to the max value. 
note: http://arxiv.org/abs/1410.2847 (with $O(n)$ time preprocessing, you can do it in $O(k)$ time each!)
---
description: Isotonic regression, bounded regression
note: see [this](https://chaoxuprime.com/posts/2015-01-27-bounded-regression-on-data-streams.html). Problem can also be defined on a DAG.
---
description:  Given integers $a_1,\ldots,a_n$, each one is either a power of 2 or a negative of a power of 2. Associated with each integer, a cost $c_1,\ldots,c_n$. Finally a integer $m$. Output $x_1,\ldots,x_n$, such that $x_i\in \{0,1\}$ such that $\sum_{i=1}^n a_i x_i = m$ and $\sum_{i=1}^n c_ix_i$ is minimized.
note: very artificial problem.
---
description: Discrete tomography in 2D
---
description: Given $a_1,\ldots,a_{2n}$, pair the numbers to maximize the sum of min of pairs.
---
description: Given a simple graph where there is an adjacency list on each vertex, find a matching that saturates $S$.
note: I recall there is a running time only depend on $|S|$? oh right it is possible. 
tag: matching
---
description: two or zero matching
note: http://cstheory.stackexchange.com/questions/33857/is-two-or-zero-matching-in-a-bipartite-graph-np-complete
tag: matching
---
description: Given a bipartite graph $G=(A\cup B, E)$ with weight function $w$ on the vertices, in strongly polynomial time, one can find $S$ a non-empty subset of $B$ such that $w(N(S))/w(S)$ is minimized.
---
description: Find minimum number of edges such that the removal increase the weight of the minimum spanning tree
note: generalize to base of matroids
tag: combinatorial optimization
---
description: Given a directed graph, find the minimum number of edges to remove so there is no arborescence.
note: also works for union of $k$-arborescence.
tag: combinatorial optimization
---
description: Given a directed graph, find the minimum number of edges to remove so there is no optimal $k$-arborescence for fixed $k$.
note: https://dl.acm.org/citation.cfm?id=2884550
tag: combinatorial optimization
---
description: compute minimum double cut. Namely find nonempty disjoint $Z_1$, $Z_2$ such that number of in-edges of $Z_1$ and $Z_2$ is minimized. 
tag: combinatorial optimization
---
description: find the minimum cut under the constraint that each side has at least $k$ vertices for constant $k$.
---
description: find the minimum cut under the constraint that each side is connected and has at least $k$ vertices for constant $k$.
note: special case of $2$ is interesting, see https://chaoxuprime.com/posts/2016-04-24-restricted-min-cut.html
---
description: $f$ is a symmetric function on $V$, find the value of min-$st$ separating set for all $s,t$, assume one have access to min-$ST$ separating set for any $S,T\subset V$.
note: $n-1$ oracle call is sufficient. 
---
description: maximum perimeter triangle, maximum dispersion set of size $k$.
note: anything better than $O(n^k)$ is good.
---
description: Let $X_A,X_B,Y_A,Y_B$ be intervals, if $A=X_A \times Y_A$ and $B=X_B\times Y_B$. Define $A\oplus_0 B = (X_A\cup X_B) \times (Y_A\cap Y_B)$ and $A\oplus_1 B = (X_A\cap X_B) \times (Y_A\cup Y_B)$. Find an algorithm such that if we are given a set of axis-aligned rectangles $S$ and a axis-aligned rectangle $R$. Device an algorithm that either find an expression using $\oplus_0$, $\oplus_1$ and rectangles in $S$, such that it covers the rectangle $R$, or return it is impossible.
note: where did I get this problem?
---
description: minimum cost path with gas stations
note: need to find time to formulate the actual problem
---
description: balanced flow, a flow of value $v$ that minimizes $\sum_{e\in E} (c(e)-f(e))^2$. 
note: Market Equilibrium via a Primal-Dual-Type Algorithm. Nikhil R. Devanur, Christos H. Papadimitriou, Amin Saberi, Vijay V. Vazirani.